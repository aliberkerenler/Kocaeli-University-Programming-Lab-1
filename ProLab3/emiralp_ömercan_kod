import os
import ast
from flask import Flask, request, render_template_string, jsonify
import pandas as pd
from pyvis.network import Network

app = Flask(__name__)

# Global değişkenler
nodes_map = {}
links_map = {}


# Excel verisini yükleyip kontrol etme
def load_excel_file(file_path):
    data = pd.read_excel(file_path)
    columns_needed = ['orcid', 'doi', 'author_position', 'author_name', 'coauthors', 'paper_title']

    missing_columns = [column for column in columns_needed if column not in data.columns]
    if missing_columns:
        raise ValueError(f"Excel dosyasında eksik sütunlar var: {', '.join(missing_columns)}")

    return data[columns_needed]

# Veriyi yükle
data = load_excel_file('dataset.xlsx')


# Yazarların toplam makale sayısını hesapla
def calculate_author_papers(data):
    papers_count = {}
    for idx, record in data.iterrows():
        try:
            coauthor_list = ast.literal_eval(record['coauthors'])
        except (ValueError, SyntaxError):
            coauthor_list = []
        coauthor_list = [author.strip() for author in coauthor_list if author]
        main_author = record['author_name'].strip()
        authors_set = set(coauthor_list)
        authors_set.add(main_author)
        for author in authors_set:
            papers_count[author] = papers_count.get(author, 0) + 1
    return papers_count

# En kısa yol bulma algoritması (BFS)
def locate_shortest_path(start, end, node_map, link_map):
    queue = [(start, [start])]
    visited = set()

    while queue:
        current, path = queue.pop(0)
        if current in visited:
            continue
        visited.add(current)

        if current == end:
            return path

        for edge in link_map:
            if current in edge:
                neighbor = edge[0] if edge[1] == current else edge[1]
                if neighbor not in visited:
                    queue.append((neighbor, path + [neighbor]))

    return []

@app.route('/shortest_path_route/<start_author>/<end_author>', methods=['GET'])
def retrieve_shortest_path(start_author, end_author):
    start_author = start_author.strip().lower()
    end_author = end_author.strip().lower()

    start_node_id = next((node_id for node_id, node_info in nodes_map.items() if
                           start_author in node_id.lower() or start_author in node_info['label'].lower()), None)
    end_node_id = next((node_id for node_id, node_info in nodes_map.items() if
                         end_author in node_id.lower() or end_author in node_info['label'].lower()), None)

    if not start_node_id or not end_node_id:
        return f"Hata: '{start_author}' veya '{end_author}' için geçerli bir yazar bulunamadı."

    shortest_path = locate_shortest_path(start_node_id, end_node_id, nodes_map, links_map)

    if not shortest_path:
        return f"{start_author} ile {end_author} arasında bir bağlantı bulunamadı."

    path_representation = " ➔ ".join([nodes_map[node]['label'] for node in shortest_path])
    path_length = len(shortest_path)

    return f"En kısa yol: {path_representation} (Uzunluk: {path_length})"

# Düğüm ağırlıklarını belirle
def find_node_weights(data, author_name):
    author_papers = calculate_author_papers(data)

    coauthors_set = set()
    for idx, record in data.iterrows():
        if record['author_name'].strip() == author_name:
            try:
                coauthors = ast.literal_eval(record['coauthors'])
                coauthors_set.update([coauthor.strip() for coauthor in coauthors])
            except (ValueError, SyntaxError):
                continue

    weights = []
    for coauthor in coauthors_set:
        if coauthor in author_papers:
            weights.append((coauthor, author_papers[coauthor]))

    weights.sort(key=lambda x: x[1], reverse=True)

    return weights

@app.route('/node_weights/<author_name>', methods=['GET'])
def retrieve_node_weights(author_name):
    weights = find_node_weights(data, author_name)
    return jsonify({'weights': [{'name': author, 'articles': count} for author, count in weights]})

def execute_dijkstra(start_id, all_nodes, all_edges):
    path_lengths = {node_id: float('inf') for node_id in all_nodes}
    path_lengths[start_id] = 0
    unvisited_nodes = list(all_nodes.keys())
    previous_nodes = {node_id: None for node_id in all_nodes}

    while unvisited_nodes:
        current_node = min(unvisited_nodes, key=lambda node: path_lengths[node])
        unvisited_nodes.remove(current_node)

        if path_lengths[current_node] == float('inf'):
            break

        for (src, tgt), edge_weight in all_edges.items():
            if src == current_node or tgt == current_node:
                neighbor_node = tgt if src == current_node else src
                new_route = path_lengths[current_node] + edge_weight
                if new_route < path_lengths[neighbor_node]:
                    path_lengths[neighbor_node] = new_route
                    previous_nodes[neighbor_node] = current_node

    return path_lengths, previous_nodes

@app.route('/shortest_paths_from_author', methods=['POST'])
def retrieve_shortest_paths_from_author():
    author_id = request.form.get('author_id')
    if not author_id or author_id not in nodes_map:
        return f"Geçersiz veya bulunamayan yazar ID: {author_id}"

    distances, previous = execute_dijkstra(author_id,    nodes_map, links_map)

    result_html = f"<h2>{nodes_map[author_id]['label']} için en kısa yollar:</h2><table border='1'><tr><th>Yazar</th><th>Mesafe</th><th>Yol</th></tr>"
    for node_id, distance in distances.items():
        if distance < float('inf'):
            path = []
            current = node_id
            while current is not None:
                path.append(nodes_map[current]['label'])
                current = previous[current]
            path = ' ➔ '.join(path[::-1])
            result_html += f"<tr><td>{nodes_map[node_id]['label']}</td><td>{distance}</td><td>{path}</td></tr>"
    result_html += "</table>"

    return result_html

def dijkstra_algorithm(graph, start_node):
    shortest_paths = {start_node: (None, 0)}
    current_node = start_node
    visited = set()

    while current_node is not None:
        visited.add(current_node)
        neighbors = graph.get(current_node, {})
        current_weight = shortest_paths[current_node][1]

        for neighbor, weight in neighbors.items():
            total_weight = current_weight + weight
            if neighbor not in shortest_paths:
                shortest_paths[neighbor] = (current_node, total_weight)
            else:
                current_shortest = shortest_paths[neighbor][1]
                if current_shortest > total_weight:
                    shortest_paths[neighbor] = (current_node, total_weight)

        next_destinations = {node: shortest_paths[node] for node in shortest_paths if node not in visited}
        if not next_destinations:
            break

        current_node = min(next_destinations, key=lambda k: next_destinations[k][1])

    return shortest_paths

@app.route('/shortest_paths_compute', methods=['POST'])
def compute_paths():
    author_id = request.form.get('author_id')
    if not author_id or author_id not in nodes_map:
        return f"Geçersiz veya bulunamayan yazar ID: {author_id}"

    graph = create_graph(author_id)
    shortest_paths = dijkstra_algorithm(graph, author_id)

    table_html = "<table border='1'><tr><th>Yazar</th><th>En Kısa Mesafe</th><th>Yol</th></tr>"
    for node in shortest_paths:
        path = []
        current = node
        while current is not None:
            path.append(nodes_map[current]['label'])
            next_node = shortest_paths[current][0]
            current = next_node
        path = path[::-1]
        distance = shortest_paths[node][1]
        table_html += f"<tr><td>{nodes_map[node]['label']}</td><td>{distance}</td><td>{' ➔ '.join(path)}</td></tr>"
    table_html += "</table>"

    return table_html

# En çok işbirliği yapan yazarı belirle
def find_top_collaborator(edges):
    collaboration_counts = {}
    for (src, tgt), weight in edges.items():
        collaboration_counts[src] = collaboration_counts.get(src, 0) + weight
        collaboration_counts[tgt] = collaboration_counts.get(tgt, 0) + weight

    top_collaborator = max(collaboration_counts, key=collaboration_counts.get)
    max_count = collaboration_counts[top_collaborator]
    return top_collaborator, max_count

@app.route('/collaborators_count/<author_input>', methods=['GET'])
def retrieve_collaborators_count(author_input):
    author_input = author_input.strip().lower()
    matching_author_ids = []

    for node_id, node_info in nodes_map.items():
        if author_input in node_id.lower() or author_input in node_info['label'].lower():
            matching_author_ids.append(node_id)

    if not matching_author_ids:
        return f"Hata: '{author_input}' için eşleşen bir yazar bulunamadı."

    collaborators_set = set()
    for (src, tgt) in links_map:
        if any(node_id.lower() == src.lower() or node_id.lower() == tgt.lower() for node_id in matching_author_ids):
            collaborators_set.add(src)
            collaborators_set.add(tgt)

    for node_id in matching_author_ids:
        collaborators_set.discard(node_id)

    total_collaborators_count = len(collaborators_set)

    return f"'{author_input}' yazarının işbirliği yaptığı toplam yazar sayısı: {total_collaborators_count}"

# En uzun yolu bulma fonksiyonu
def locate_longest_path(current, visited=None, path=None):
    if visited is None:
        visited = set()
    if path is None:
        path = []

    visited.add(current)
    path.append(current)

    longest_path = path.copy()
    for (src, tgt) in links_map:
        if src == current and tgt not in visited:
            new_path = locate_longest_path(tgt, visited, path)
            if len(new_path) > len(longest_path):
                longest_path = new_path
        elif tgt == current and src not in visited:
            new_path = locate_longest_path(src, visited, path)
            if len(new_path) > len(longest_path):
                longest_path = new_path

    visited.remove(current)
    path.pop()

    return longest_path

@app.route('/longest_path_route', methods=['POST'])
def retrieve_longest_path():
    author_id = request.form.get('author_id')
    if not author_id or author_id not in nodes_map:
        return f"Geçersiz veya bulunamayan yazar ID: {author_id}"

    longest_path_found = locate_longest_path(author_id)
    path_labels = " ➔ ".join([nodes_map[node]['label'] for node in longest_path_found])
    path_length = len(longest_path_found)

    return f"Yazar {nodes_map[author_id]['label']} için en uzun yol: {path_labels} (Uzunluk: {path_length})"

# Düğüm ve Kenar yapılarını oluştur
def build_graph(data):
    global nodes_map, links_map
    nodes_map = {}
    links_map = {}
    main_authors = set()

    for idx, record in data.iterrows():
        author = record['author_name'].strip()
        orcid = record['orcid']
        paper = record['paper_title']
        doi = record['doi']
        position = record['author_position']

        try:
            coauthor_list = ast.literal_eval(record['coauthors'])
        except (ValueError, SyntaxError):
            coauthor_list = []
        coauthor_list = [coauthor.strip() for coauthor in coauthor_list]

        if 1 <= position <= len(coauthor_list):
            position -= 1
            primary_coauthor = coauthor_list[position]
            coauthor_list.remove(primary_coauthor)

        node_key = f"{author}-{orcid}"
        if node_key not in nodes_map:
            nodes_map[node_key] = {
                "label": author,
                "orcid": orcid,
                "papers": {},
                "color": "purple"
            }
            main_authors.add(node_key)

        nodes_map[node_key]["papers"][doi] = paper

        for coauthor in coauthor_list:
            if not coauthor:
                continue
            coauthor_key = coauthor
            if coauthor_key not in nodes_map:
                nodes_map[coauthor_key] = {
                    "label": coauthor,
                    "orcid": "N/A",
                    "papers": {},
                    "color": "yellow"
                }
            edge_pair = tuple(sorted((node_key, coauthor_key)))
            if edge_pair not in links_map:
                links_map[edge_pair] = 0
            links_map[edge_pair] += 1
    return nodes_map, links_map, main_authors

# Grafiği oluştur ve HTML çıktısı üret
def generate_graph_html(node_map, link_map, author_paper_count):
    net = Network(height="800px", width="100%", bgcolor="#2D2D2D", font_color="white")
    net.set_options(""" 
    var options = {
      "nodes": {
        "scaling": {
          "min": 10,
          "max": 50
        }
      },
      "edges": {
        "arrows": {
          "to": false
        },
        "color": {
          "inherit": true
        },
        "smooth": false
      },
      "physics": {
        "enabled": true,
        "solver": "forceAtlas2Based",
        "forceAtlas2Based": {
          "gravitationalConstant": -300,
          "centralGravity": 0.005,
          "springLength": 200,
          "springConstant": 0.03
        },
        "minVelocity": 0.5,
        "timestep": 0.35
      }
    }
    """)

    avg_papers = sum(author_paper_count.values()) / len(author_paper_count)
    for key, value in node_map.items():
        author_name = value['label']
        total_papers = author_paper_count.get(author_name, 0)
        papers_info = value.get("papers", {})
        paper_details = "<br>".join(
            [f"<b>DOI:</b> {doi} - <b>Başlık:</b> {title}" for doi, title in papers_info.items()])

        if total_papers > avg_papers * 1.2:
            size = 80
            color = "purple"
        elif total_papers < avg_papers * 0.8:
            size = 40
            color = "yellow"
        else:
            size = 60
            color = "green"

        net.add_node(
            key,
            label=value['label'],
            title=f"""
                <b>Yazar:</b> {value['label']}<br>
                <b>ORCID:</b> {value['orcid']}<br>
                <b>Toplam Makale Sayısı:</b> {total_papers}<br>
                <b>Makaleler:</b><br>{paper_details if paper_details else 'Bu yazar için makale bilgisi yok.'}
            """,
            color=color,
            size=size
        )

    for (start, end), weight in link_map.items():
        net.add_edge(start, end, value=weight, width=weight * 2, title=f"Ortak Makale Sayısı: {weight}", color="white")

    return net

def create_graph(author_id):
    weighted_graph = {}
    for (src, tgt), weight in links_map.items():
        if src == author_id or tgt == author_id:
            if src not in weighted_graph:
                weighted_graph[src] = {}
            if tgt not in weighted_graph:
                weighted_graph[tgt] = {}
            weighted_graph[src][tgt] = weight
            weighted_graph[tgt][src] = weight
    return weighted_graph

@app.route('/', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        if 'file' not in request.files:
            return 'Dosya bölümü mevcut değil'
        file = request.files['file']
        if file.filename == '':
            return 'Dosya seçilmedi'
        if file:
            file_path = os.path.join('uploads', file.filename)
            file.save(file_path)
            df = load_excel_file(file_path)
            papers_per_author = calculate_author_papers(df)
            nodes_map, links_map, primary_authors_set = build_graph(df)
            graph_html = generate_graph_html(nodes_map, links_map, papers_per_author)
            top_collaborator, collab_count = find_top_collaborator(links_map)

            html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Graph Visualization Interface</title>
    <style>
        body {{
            display: flex;
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #e9ecef;
        }}
        #sidebar {{
            width: 20%;
            background: #f0f0f0;
            color: #333;
            display: flex;
            flex-direction: column;
            padding: 10px;
            height: 100vh;
            box-sizing: border-box;
            border-right: 1px solid #ccc;
        }}
        #sidebar h3 {{
            text-align: center;
            margin-bottom: 10px;
            color: #007bff;
        }}
        #button-container {{
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-evenly;
        }}
        .btn {{
            margin: 5px 0;
            padding: 10px;
            text-align: center;
            background: #007bff;
            color: white;
            border: 1px solid white;
            cursor: pointer;
            border-radius: 5px;
        }}
        .btn:hover {{
            background: #0056b3;
        }}
        #result {{
            width: 20%;
            background: #f8f9fa;
            color: #333;
            padding: 10px;
            overflow-y: auto;
            border: 1px solid #ccc;
            border-radius: 5px;
            height: 100vh;
            box-sizing: border-box;
        }}
        #graph-area {{
            flex: 1;
            height: 100vh;
            padding: 10px;
        }}
    </style>
    <script>
        function displayResult(content) {{
            document.getElementById('result').innerHTML = content;
        }}

        function findShortestPath() {{
            const start = prompt("Başlangıç yazarını girin:");
            const end = prompt("Bitiş yazarını girin:");
            if (start && end) {{
                fetch(`/shortest_path_route/${{start}}/${{end}}`)
                    .then(response => response.text())
                    .then(data => displayResult(data))
                    .catch(error => displayResult('Hata: ' + error));
            }}
        }}

        function showLeadingCollaborator() {{
            const content = "En çok işbirliği yapan yazar: {top_collaborator} (İşbirlikleri: {collab_count})";
            displayResult(content);
        }}

        function generateBSTFromQueue() {{
            displayResult('Kuyruktan BST oluşturuluyor...');
        }}

        function computeShortestPaths() {{
            const authorId = prompt("Yazar ID'sini girin (örneğin: 'John Doe-1234'):");
            if (!authorId) {{
                displayResult("Yazar ID'si girilmedi.");
                return;
            }}
            fetch('/shortest_paths_from_author', {{
                method: 'POST',
                headers: {{
                    'Content-Type': 'application/x-www-form-urlencoded',
                }},
                body: `author_id=${{authorId}}`,
            }})
            .then(response => response.text())
            .then(data => displayResult(data))
            .catch(error => displayResult("Hata: " + error.message));
        }}

        function computeCollaboratorCount() {{
            const authorId = prompt("Yazar ID'sini girin (örneğin: 'John Doe-1234'):");
            if (authorId) {{
                fetch(`/collaborators_count/${{authorId}}`)
                    .then(response => response.text())
                    .then(data => displayResult(data))
                    .catch(error => displayResult('Hata: ' + error));
            }}
        }}

        function computeNodeWeights() {{
            const authorId = prompt("A yazarının ID'sini girin:");
            if (authorId) {{
                fetch(`/node_weights/${{authorId}}`)
                    .then(response => response.json())
                    .then(data => {{
                        let content = 'Düğüm ağırlıkları:<br>';
                        data.weights.forEach(weight => {{
                            content += `${{weight.name}}: ${{weight.articles}} makale<br>`;
                        }});
                        displayResult(content);
                    }})
                    .catch(error => displayResult('Hata: ' + error));
            }}
        }}

        function findLongestPath() {{
            const authorId = prompt("Bir yazar ID'si girin:");
            if (!authorId) {{
                displayResult("Yazar ID'si girilmedi.");
                return;
            }}
            fetch('/longest_path_route', {{
                method: 'POST',
                headers: {{
                    'Content-Type': 'application/x-www-form-urlencoded',
                }},
                body: `author_id=${{authorId}}`,
            }})
            .then(response => response.text())
            .then(data => displayResult(data))
            .catch(error => displayResult("Hata: " + error.message));
        }}
    </script>
</head>
<body>
    <div id="sidebar">
        <h3>Actions</h3>
        <div id="button-container">
            <div class="btn" onclick="findShortestPath()">1. A ve B yazarları arasındaki en kısa yol</div>
            <div class="btn" onclick="computeNodeWeights()">2. A yazarı için düğüm ağırlıkları</div>
            <div class="btn" onclick="generateBSTFromQueue()">3. Kuyruktan BinarySearchTree oluşturma</div>
            <div class="btn" onclick="computeShortestPaths()">4. Kısa yollar</div>
            <div class="btn" onclick="computeCollaboratorCount()">5. İşbirliği yaptığı yazar sayısı</div>
            <div class="btn" onclick="showLeadingCollaborator()">6. En çok işbirliği yapmış yazar</div>
            <div class="btn" onclick="findLongestPath()">7. En uzun yol</div>
        </div>
    </div>
    <div id="graph-area">
        {graph_html.generate_html()}
    </div>
    <div id="result">
        Results will be displayed here.
    </div>
</body>
</html>

"""
            return render_template_string(html_content)

    return '''
    <!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel Dosyası Yükle</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            background-color: #e9ecef; 
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            box-sizing: border-box;
        }}
        .container {{
            background-color: #ffffff; 
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 350px; 
        }}
        h1 {{
            font-size: 28px; 
            margin-bottom: 20px;
            color: #343a40; 
        }}
        input[type="file"] {{
            margin-bottom: 20px;
            width: 100%;
            padding: 12px;
            border: 2px solid #007bff; 
            border-radius: 4px;
            font-size: 16px; 
            transition: border-color 0.3s; 
        }}
        input[type="file"]:hover {{
            border-color: #0056b3;
        }}
        input[type="submit"] {{
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            font-size: 18px; 
            transition: background-color 0.3s;
        }}
        input[type="submit"]:hover {{
            background-color: #0056b3;
        }}
    </style>
</head>
<body>
        <div class="container">
            <h1>Excel Dosyası Yükle</h1>
            <form method="post" enctype="multipart/form-data">
                <input type="file" name="file" accept=".xls,.xlsx" required>
                <input type="submit" value="Yükle">
            </form>
        </div>
    </body>
    </html>

    '''

if __name__ == '__main__':
    os.makedirs('uploads', exist_ok=True)
    app.run(debug=True)
